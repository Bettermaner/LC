# 给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。
# 任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。

# 然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

# 你需要计算完成所有任务所需要的 最短时间 。

# 输入：tasks = ["A","A","A","B","B","B"], n = 2
# 输出：8
# 解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
# 在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态

# 解题思路

# 完成所有任务的最短时间取决于出现次数最多的任务数量。
# 看下题目给出的例子
# 输入: tasks = ["A","A","A","B","B","B"], n = 2
# 输出: 8
# 执行顺序: A -> B -> (待命) -> A -> B -> (待命) -> A -> B.

# 很容易观察到，前面两个 A 任务一定会固定跟着 2 个单位时间的间隔。
# 最后一个 A 之后是否还有任务跟随取决于是否存在与任务 A 出现次数相同的任务。

# 该例子的计算过程为：
# (任务 A 出现的次数 - 1) * (n + 1) + (出现次数为 3 的任务个数)，
# 即：n+1 代表每次一个任务执行的时间窗口大小，最后一次执行任务取决于出现次数最多的任务的个数
# (3 - 1) * (2 + 1) + 2 = 8

# 特殊情况
# 然而存在一种特殊情况，例如：
# 输入: tasks = ["A","A","A","B","B","B","C","C","D","D"], n = 2
# 输出: 10
# 执行顺序: A -> B -> C -> A -> B -> D -> A -> B -> C -> D
# 此时如果按照上述方法计算将得到结果为 8，比数组总长度 10 要小，应返回数组长度。

# 个人的理解：顺着楼主预先设置冷却时间，然后再插入的解法。我们想想一下，当算出来的结果小于数组长度，
# 说明所有的冷却单位都被插满了，但是还有任务没被插进去。
# 这种情况说明这个数组的任务无需冷却时间，（退化成了n=0这种情况），所以最短时间就是数组长度。



# 所以整体的解题步骤如下：
# 计算每个任务出现的次数
# 找出出现次数最多的任务，假设出现次数为 x
# 计算至少需要的时间 (x - 1) * (n + 1)，记为 min_time
# 计算出现次数为 x 的任务总数 count，计算最终结果为 min_time + count

def func(task,n):
    l = len(task)
    if l <= 1:
        return l

    task_count = {}
    for t in task:
        task_count[t] = task_count.get(t,0) + 1

    # 按任务出现的次数从大到小排序
    task_sort = sorted(task_count.items(), key=lambda x: x[1], reverse=True)

    max_count = task_sort[0][1]
    
    min_time = (max_count -1) * (n + 1)

    for sort in task_sort:
        if sort[1] == max_count:
            min_time += 1 

    # 如果结果比任务数量少，则返回总任务数
    return min_time if min_time > l else l

print(func(["A","A","A","B","B","B"],2))