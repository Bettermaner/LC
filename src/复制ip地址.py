
# ç»™å®šä¸€ä¸ªåªåŒ…å«æ•°å­—çš„å­—ç¬¦ä¸² s ï¼Œç”¨ä»¥è¡¨ç¤ºä¸€ä¸ª IP åœ°å€ï¼Œè¿”å›žæ‰€æœ‰å¯èƒ½ä»Ž s èŽ·å¾—çš„ æœ‰æ•ˆ IP åœ°å€ ã€‚ä½ å¯ä»¥æŒ‰ä»»ä½•é¡ºåºè¿”å›žç­”æ¡ˆã€‚

# æœ‰æ•ˆ IP åœ°å€ æ­£å¥½ç”±å››ä¸ªæ•´æ•°ï¼ˆæ¯ä¸ªæ•´æ•°ä½äºŽ 0 åˆ° 255 ä¹‹é—´ç»„æˆï¼Œä¸”ä¸èƒ½å«æœ‰å‰å¯¼ 0ï¼‰ï¼Œæ•´æ•°ä¹‹é—´ç”¨ '.' åˆ†éš”ã€‚

# ä¾‹å¦‚ï¼š"0.1.2.201" å’Œ "192.168.1.1" æ˜¯ æœ‰æ•ˆ IP åœ°å€ï¼Œä½†æ˜¯ "0.011.255.245"ã€"192.168.1.312" å’Œ "192.168@1.1" æ˜¯ æ— æ•ˆ IP åœ°å€ã€‚



# ðŸ§  è§£é¢˜æ€è·¯ï¼šå›žæº¯æ³•ï¼ˆBacktrackingï¼‰
# è¿™ä¸ªé—®é¢˜éžå¸¸é€‚åˆä½¿ç”¨ å›žæº¯æ³• æ¥è§£å†³ã€‚æˆ‘ä»¬å°è¯•åœ¨å­—ç¬¦ä¸²ä¸­æ’å…¥ 3 ä¸ªç‚¹ï¼Œå°†å­—ç¬¦ä¸²åˆ’åˆ†ä¸º 4 æ®µï¼Œæ¯æ®µå¿…é¡»æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š

# âœ… æœ‰æ•ˆ IP æ®µçš„åˆ¤æ–­è§„åˆ™ï¼š
# é•¿åº¦ä¸º 1~3 ä½ï¼›
# æ•°å€¼èŒƒå›´ä¸º 0~255ï¼›
# ä¸èƒ½æœ‰å‰å¯¼é›¶ï¼Œé™¤éžè¯¥æ®µå°±æ˜¯ '0' æœ¬èº«ã€‚

# æ‰€ä»¥æ€»ä½“æ—¶é—´å¤æ‚åº¦æ˜¯ O(1)ï¼ˆå› ä¸ºåˆ’åˆ†æ–¹å¼æ•°é‡å›ºå®šã€æœ‰é™ï¼‰ã€‚

def restoreIpAddresses(s: str):
    def is_valid(segment: str) -> bool:
        # é•¿åº¦å¤§äºŽ1æ—¶ä¸èƒ½ä»¥0å¼€å¤´
        if len(segment) > 1 and segment[0] == '0':
            return False
        # æ•°å€¼å¿…é¡»åœ¨0~255ä¹‹é—´
        return 0 <= int(segment) <= 255

    def backtrack(start: int, path: list):
        # å¦‚æžœå·²ç»é€‰äº†4æ®µï¼Œå¹¶ä¸”èµ°åˆ°äº†å­—ç¬¦ä¸²æœ«å°¾ï¼Œåˆ™æ˜¯ä¸€ä¸ªæœ‰æ•ˆIP
        if len(path) == 4:
            if start == len(s):
                result.append(".".join(path))
            return

        # å°è¯•æˆªå–1~3ä¸ªå­—ç¬¦ä½œä¸ºå½“å‰æ®µ
        for length in range(1, 4):
            end = start + length
            if end > len(s):
                break
            segment = s[start:end]
            if is_valid(segment):
                backtrack(end, path + [segment])

    result = []
    backtrack(0, [])
    return result